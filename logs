#!/bin/bash

RED='\033[0;31m'
CYAN='\033[0;36m'
NC='\033[0m'
set -euo pipefail

if [[ $1 = -h ]]; then
	echo -e "${RED}logs <file> [ c | in <regex> ] [--no-tail] [--debug]${NC}"
	echo Give list of strings to exclude/include from the file.
	echo
	echo "c         -> toggle inclusion of colour. Default is to give coloured output. Using c once will disable it on strings going forward. Using c again will enable it for the following strings, and so on."
	echo "in        -> include following file. Default is exclude."
	echo "id        -> Give the 'name' of something whose ID you want to filter out, e.g. CC_Cloud"
	echo "--no-tail -> Do not limit the output to any line number."
	echo "--no-map  -> Do not map IDs onto names"
	echo "--debug   -> Pass --debug to map-IDs.sh"
	exit 0
fi

query=""
in=

declare -a idArray
declare -a inArray

mappingDir=$MAPS
colour=true
noTail=false
noMap=false
file=$1
debug=
shift 1 # Exclusions from now on

while [[ $# -gt 0 ]]; do
	line="$1"
	if [[ "$line" = "" ]]; then
		break
	elif [[ "$line" = "c" ]]; then
		if [[ "$colour" = true ]]; then
			colour=false
		else
			colour=true
		fi
	elif [[ $line = --no-map ]]; then
		noMap=true
	elif [[ $line = --no-tail ]]; then
		noTail=true
	elif [[ $line = --debug ]]; then
		debug=--debug
	elif [[ "$line" = "id" ]]; then
		idArray+=("$2")
		shift 1
	elif [[ "$line" != "in" ]]; then
		query+=" | grep -v \"$line\""
	else
		in+=" | grep -i \"$2\""
		inArray+=("$2")
		shift 1
	fi
	shift 1
done

logdir="$(dirname "$(realpath $file)")"
while [[ ! -f "$logdir/cluster.txt" && "$logdir" != / ]]; do
	logdir="$(dirname "$logdir")"
done

clusterTxt="$logdir"/cluster.txt
if [[ ! -f $clusterTxt ]]; then
	exit 1
fi

downloadInfoFile="$logdir"/download_info

if [[ ! -f "$downloadInfoFile" ]]; then
	tmpFile="$(dirname '$(realpath $file)')"/.vmsname
	if [[ -f $tmpFile ]]; then
		vmsName=$(cat $tmpFile)
	fi

	if [[ -z ${vmsName:-x} ]] || [[ ! -f /tmp/${vmsName:-blablabla} ]]; then
		echo "What is this VMS called? (You forgot to include a download_info file). This WILL create a permanent file."
		read -p "VMS name: " vmsName
		downloadInfoFile=/tmp/$vmsName
		echo "VMS name:" > $downloadInfoFile
		echo $vmsName >> $downloadInfoFile
		echo $vmsName > $tmpFile
	else
		downloadInfoFile=/tmp/$vmsName
	fi
fi

vmsName=$(sed -n '2p' "$downloadInfoFile")
vmsName=${vmsName/\/*/}
mappingFile=$mappingDir/$vmsName

if [[ ! -f $mappingFile ]]; then
	construct-name-mappings.sh -vms $vmsName --source "$clusterTxt"
fi

for id in "${idArray[@]}"; do
	idName=$(map-IDs.sh $vmsName --reverse $id)
	if [[ -z $idName ]]; then
		echocolour "No ID associated with name $id"
		exit 0
	fi
	query+=" | grep -v \"$idName\""
done

echo "Re-grepping ${inArray[@]}"
for g in "${inArray[@]}"; do
	in+=" | grep -i '$g'"
	if [[ $colour = true ]]; then
		in+=" --color=always"
	fi
done

command="cat $file $query $in"

if [[ $noTail = false ]]; then
	command+=" | tail -n 100"
fi

if [[ $noMap = false ]]; then
	command+=" | map-IDs.sh $vmsName $debug"
fi

newCmd="${command//$CYAN//}"
echocolour "${newCmd//$NC//}"
eval "$command"