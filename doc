#!/usr/bin/env bash

set -euo pipefail
IFS=$'\n\t'

printCommands () {
cat <<EOF
Tell me what to do

Both servces:
- make    [EOF|full]                 Create and run both services ("full" means also create the database, table, and field)
- drop                               Stop and destroy all services
- purge                              Same as "drop" + deletes all data; same as init
- ps                                 Print docker ps
- psa                                Print docker ps -a
- reload                             Destroy the service, build code again, make new service (alias to "purge; build; make full")

Both or individual (EOF means no further input, command runs for both):
- run     [EOF|master|slave|slaves]  Start service (slaves means all nodes except master)
- stop    [EOF|master|slave|slaves]  Stop service
- restart [EOF|master|slave|slaves]  Alias to "stop <option>; start <same option>"

Individual service (EOF is same as master, slave must be specified):
- bash    [EOF|master|slave]         Run root shell inside service
- path    [EOF|master|slave]         Same as "bash" but with postgres user
- conf    [EOF|master|slave]         Open postgresql.conf of service in vim
- perm    [EOF|master|slave]         Open pg_hba.conf of service in vim
- log     [-f] [EOF|master|slave]    Show logs (optionally follow) of given node inside the less command

Misc:
- build                              Runs make rule for building the db container
- init    [num-of-nodes]             Build the file structure and assign the right user to it
- backup                             Backup master, copy to all slaves, then start secondaries as standby servers
- -h|--help                          Print full description of this tool
-                                    Print this text
EOF
}

printHelp () {
	printCommands
cat <<EOF

# INIT

The init option creates the desired file structure in /tmp. You need to provide the number of desired
slave nodes, which defaults to 1. Other options which need to know this number simply look at the file
structure created in this way. This eliminates the need for global variables.

If a file structure already exists, this is deleted. Note that we destroy any existing data this way.

The slave config directories will hold a 'master_exists' file, which tells their docker images that they
are running in slave mode.

Init can be used as an alias for purge.

# FILE STRUCTURE

Inside of the /tmp directory we create a 'docker' directory with the following file structure:

/tmp/docker:

├─ databases/		(holds the DB data)
|  ├─ master/
|  ├─ slave_1/
|  ├─ slave_2/
|  ├─ ...
├─ config/			(holds the master_exists file and other similar configuration signal files)
|  ├─ master_config/
|  ├─ slave_1_config/
|  |  ├─ master_exists
|  ├─ slave_2_config/
|  |  ├─ master_exists
|  ├─ ...
├─ backup/			(holds the backup file structure)
|  ├─ master/
|  |  ├─ archive/	(master DB is archived here)
|  |  ├─ copy/		(slave DB archive is copied here)
|  ├─ slave_1/
|  |  ├─ archive/	(slave DB is archived here)
|  |  ├─ copy/		(master DB archive is copied here)
|  ├─ ...

Everything inside the docker directory belongs to the user 70, which is the docker postgres user. 

# REFERENCING NODES

Nodes are referenced by their function in the cluster. We always here 'master'. Secondaries are referenced by
their number, e.g. '1' would translate to slave_1.

When the above documentation lists 'slave' as a potential option to a command, we mean the number, not the
word slave. On the other hand, if the option says 'master', we need the word 'master'.
EOF
}

init () {
	howMany=$1 # Number of slave nodes in the server group

	sudo rm -rf /tmp/docker
	sudo mkdir /tmp/docker
	cd /tmp/docker

	# database volumes
	sudo mkdir databases
	cd databases
	
	sudo mkdir master
	i=1
	while [[ $i -lt $((howMany + 1)) ]]; do
		echo "Creating slave_$i database/"
		sudo mkdir slave_$i
		((i = $i + 1))
	done

	cd ..

	# Archive volumes
	sudo mkdir backup
	cd backup

	sudo mkdir master master/archive master/copy
	i=1
	while [[ $i -lt $((howMany + 1)) ]]; do
		echo "Creating slave_$i backup/"
		sudo mkdir slave_$i "slave_$i"/archive "slave_$i"/copy
		((i = $i + 1))
	done

	cd ..

	# Cluster configuration
	sudo mkdir config
	cd config

	sudo mkdir master
	i=1
	while [[ $i -lt $((howMany + 1)) ]]; do
		echo "Creating slave_$i config/"
		sudo mkdir slave_$i
		sudo touch slave_$i/primary_exists
		((i = $i + 1))
	done


	cd ..

	# Assign permissions
	sudo find /tmp/docker -exec chown 70 {} \;

	# Clear docker images
	docker stop master 2>/dev/null || echo "" > /dev/null
	docker rm master 2>/dev/null || echo "" > /dev/null
	for i in $(eval echo "{1..$howMany}"); do
		docker stop slave_$i 2>/dev/null || echo "" > /dev/null
		docker rm slave_$i 2>/dev/null || echo "" > /dev/null
	done
}

howManySlaves () {
	howMany=$(ls -1 /tmp/docker/config/slave* 2>/dev/null | grep slave_ | wc -l)
	echo $howMany
}

if [[ -z "${1:-}" ]]; then
	echocolour "No commands given"
	printCommands
	exit 1
fi

case "$1" in
	--help|-h)
		printHelp
		;;
	init)
		init "${2:-1}"
		;;
	ps)
		docker ps
		;;
	psa)
		docker ps -a
		;;
	run|start)
		numSlaves=`howManySlaves`
		
		what=all
		if [[ "${2:-}" = master ]]; then
			echo "Starting master"
			what=master
		elif [[ "${2:-}" = slaves ]]; then
			echo "Starting all slaves"
			what=slaves
		elif [[ ! -z "${2:-}" ]]; then
			echo "Starting slave_$2"
			what=slave_"$2"
		else
			echo "Starting all"
		fi

		if [[ $what = master ]] || [[ $what = all ]]; then
			docker start master
		fi

		i=1
		while [[ $i -lt $((numSlaves + 1)) ]]; do
			if [[ $what = all ]] || [[ $what = slaves ]] || [[ $what = slave_$i ]]; then
				docker start slave_$i
			fi
			((i = i + 1))
		done
		;;
	stop)
		numSlaves=`howManySlaves`
		
		what=all
		if [[ "${2:-}" = master ]]; then
			echo "Stopping master"
			what=master
		elif [[ "${2:-}" = slaves ]]; then
			echo "Stopping all slaves"
			what=slaves
		elif [[ ! -z "${2:-}" ]]; then
			echo "Stopping slave_$2"
			what=slave_"$2"
		else
			echo "Stopping all"
		fi

		if [[ $what = master ]] || [[ $what = all ]]; then
			docker stop master 2>/dev/null
		fi

		i=1
		while [[ $i -lt $((numSlaves + 1)) ]]; do
			if [[ $what = all ]] || [[ $what = slaves ]] || [[ $what = slave_$i ]]; then
				docker stop slave_$i
			fi
			((i = i + 1))
		done
		;;

	restart)
		shift 1
		doc stop $@
		doc start $@
		;;

	make)
		numSlaves=`howManySlaves`
		
		docker run \
			   --name master \
			   -v /tmp/docker/databases/master:/var/lib/postgresql/data \
			   -v /tmp/docker/backup/master:/backup/me \
			   -v /tmp/docker/config:/config \
			   db 1>/dev/null &

		i=1
		while [[ $i -lt $((numSlaves + 1)) ]]; do
			echo "Configuring slave_$i"
			docker run \
				   --name slave_$i \
				   -v /tmp/docker/databases/slave_$i:/var/lib/postgresql/data \
				   -v /tmp/docker/backup/master:/backup/master \
				   -v /tmp/docker/backup/slave_$i:/backup/me \
				   -v /tmp/docker/config/slave_$i:/config \
				   db 1>/dev/null &

			((i = i + 1))
		done

		if [[ "${2:-}" = full ]]; then
			echo "Full make initiated"
			echo "sleeping..."
			sleep 2
			echo "woke up"
			echo "making a database"
			docker exec master bash -c "psql -U postgres -c 'CREATE DATABASE rep;'"
			echo "making table 'ps'"
			docker exec master bash -c "psql -U postgres -d rep -c 'CREATE TABLE ps (name TEXT);'"
			echo "inserting 'alex' to 'ps'"
			docker exec master bash -c 'psql -U postgres -d rep -c "INSERT INTO ps VALUES ('"'"'alex'"'"')"'
			echo "done with database initialisation"
		fi
		;;
	drop)
		numSlaves=`howManySlaves`

		echo "Stopping and removing master"
		docker stop master || echo "" >> /dev/null
		docker rm master || echo "" >> /dev/null

		i=1
		while [[ $i -lt $((numSlaves + 1)) ]]; do
			echo "Stopping and removing slave_$i"
			docker stop slave_$i 2>/dev/null || echo "" >> /dev/null
			docker rm slave_$i 2>/dev/null || echo "" >> /dev/null
			((i = i + 1))
		done
		;;
	purge)
		howMany=`howManySlaves`
		doc drop
		init $howMany
		;;
	reload)
		doc drop
		doc purge
		doc build
		doc make full
		;;
	bash)
		if [[ ! -z "${2:-}" ]]; then
			docker exec -it slave_$2 bash
		else
			docker exec -it master bash
		fi
		;;
	pash)
		if [[ ! -z "${2:-}" ]]; then
			docker exec -it slave_$2 bash -c "su - postgres"
		else
			docker exec -it master bash -c "su - postgres"
		fi
		;;
	conf)
		if [[ ! -z "${2:-}" ]]; then
			sudo vim /tmp/slave_$2/postgresql.conf
		else
			sudo vim /tmp/master/postgresql.conf
		fi
		;;
	perm)
		if [[ ! -z "${2:-}" ]]; then
			sudo vim /tmp/slave_$2/pg_hba.conf
		else
			sudo vim /tmp/master/pg_hba.conf
		fi
		;;
	build)
		COMPONENTS=db make -C "$VAION_PATH" build_vms_bazel_image
		;;
	log)
		follow=false
		if [[ ${2:-} = f ]]; then
			follow=true
			shift 1
		fi

		if [[ ${2:-} = master ]] || [[ -z ${2:-} ]]; then
			who=master
		else
			who=slave_$2
		fi

		if [[ $follow = true ]]; then
			echo "Logs with follow"
			docker logs -f $who
		else
			echo "Logs without follow"
			docker logs $who | less
		fi
		;;
	backup)
		numSlaves=`howManySlaves`

		test ! -z "$(sudo ls /tmp/docker/backup/master/archive/)" && sudo rm -r /tmp/docker/backup/master/archive/*

		echo "Backing up master..."
		docker exec master bash -c 'su -c "pg_basebackup -D /backup/me/archive" - postgres'
		echo "Backup complete"

		echo "Copying to slaves..."
		i=1
		while [[ $i -lt $((numSlaves + 1)) ]]; do
			doc stop $i

			sudo cp -p /tmp/docker/databases/slave_$i/pg_hba.conf /tmp/docker/
			
			sudo rm -fr /tmp/docker/databases/slave_$i/*
			sudo cp -pR /tmp/docker/backup/master/archive/* /tmp/docker/databases/slave_$i/
			sudo rm -fr /tmp/docker/databases/slave_$i/pg_wal/*

			sudo mv -f /tmp/docker/pg_hba.conf /tmp/docker/databases/slave_$i/

			sudo touch /tmp/docker/databases/slave_$i/standby.signal
			sudo find /tmp/docker/databases/slave_$i -exec chown 70 {} \;

			doc run $i

			((i = i + 1))
		done
		echo "Slaves updated with new data"
		;;
	*)
		echocolour "Unknown commands '$@'"
		printCommands
		;;
esac
