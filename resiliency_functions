#!/bin/bash

# This file defines commonly used functions for manipulating high availability run_cluster tests.
# It expects to run run_cluster in a hybrid mode with at least 3 nodes in the secondary server group.
# If you use run, then 3 nodes will be used.
#
# It is assumed that there exist two directories in ~/ which hold pre-build configurations
# of run_cluster so we do not have to rebuild them every time, which is tedious and racy. The directories
# are:
clean_cluster=~/cluster_CLEAN.bk # holds a clean build with no HA enabled.
ha_cluster=~/cluster_HA.bk       # holds a build with high availability already enabled.

function get {
	curl http://localhost:8080/api/v1/serverGroups | jq '.[].id'
}

function setha {
	for node in 2 3 4; do
		port=$((5432 + ($node - 1) * 4))
		docker exec postgres_$node psql -U postgres -p $port -d vaionmgmt -c "update server_groups set highly_available = true where primary_site = false;"
	done
}

function unsetha {
	for node in 2 3 4; do
		port=$((5432 + ($node - 1) * 4))
		docker exec postgres_$node psql -U postgres -p $port -d vaionmgmt -c "update server_groups set highly_available = false;"
	done
}

function sethaapi {
	id=$(curl http://localhost:8080/api/v1/serverGroups | jq '.[].id' | tail -n 1 | sed 's/"//g')
	echo
	echo $id
	curl http://localhost:8080/api/v1/serverGroups/$id -v -X PUT -d '{"highly_available":true}'
}

function unsethaapi {
	id=$(curl http://localhost:8080/api/v1/serverGroups | jq '.[].id' | tail -n 1 | sed 's/"//g')
	echo
	echo $id
	curl http://localhost:8080/api/v1/serverGroups/$id -v -X PUT -d '{"highly_available":false}'
}

function db {
	container="${1:-2}"
	port=$((5432 + ($container - 1) * 4))

	if [[ ! -z ${2:-} ]]; then
		port=$(($port + 1))
		echocolour "Entering replica DB of postgres_$container on port $port"
	else
		echocolour "Entering local DB of postgres_$container on port $port"
	fi
	
	docker exec -it postgres_$container psql -U postgres -d vaionmgmt -p $port
}

function sh {
	node=$1
	docker exec -it postgres_$node bash
}

function run {
	# Arg 1:
	#   - clean = start from scratch
	#   - old   = restart existing cluster
	#   - ready = run cluster with HA enabled

	target="${1:-clean}"
	src=$clean_cluster
	if [[ $target = ready ]]; then
		src=$ha_cluster
	fi

	runCluster=$VAION_PATH/scripts/run_cluster
	
	if [[ ! -d $src ]] || [[ $target = new ]]; then
		echocolour "Creating new cluster"
		sudo rm -rf ~/cluster
		$runCluster --hybrid 3 -r
	elif [[ $target = old ]]; then
		echocolour "Restarting old cluster"
		$runCluster --hybrid 3
	else
		echocolour "Running existing cluster in $target mode"
		sudo rm -rf ~/cluster && sudo cp -ar $src ~/cluster
		$runCluster --hybrid 3
	fi
}

# Get port of desired database on given node.
function getDBPort {
	# Args:
	#   - 1 = container/node
	#   - 2 = bool; true -> connect to the replica DB (default false).

	container=$1
	replica=${2:-no}

	port=$((5432 + ($container - 1) * 4))

	if [[ $replica != no ]]; then
		port=$((port + 1))
	fi

	echo $port
}

function insertDisk {
	# Default is the second node, as that is where we want the disks replicated
	# from.
	#
	# Args:
	#   - 1 = container/node
	#   - 2 = OPTIONAL disk serial
	#   
	# If 2 isn't given, look for the highest disk serial that already exists on
	# the node, and insert a new disk with an incremented serial.
	container="${1:-2}"
	port=$(getDBPort $container)
	diskId="${2:-}"

	if [[ -z $diskId ]]; then
		while read diskName; do
			if [[ $diskName =~ ^[1-9]+$ ]]; then
				diskId=$(($diskName + 1))
				break
			fi
		done < <(getDisks $container t '' t)
	fi

	if [[ -z $diskId ]]; then
		diskId=1
	fi

	echo "Inserting disk $diskId to node $container"
	docker exec postgres_$container psql -U postgres -d vaionmgmt -p $port -c "INSERT INTO disks (serial, name, size, present) VALUES ('$diskId','$diskId',1, true);"
}

function getDisks {
	# Args:
	#   - 1 = container (AKA node). Default 3
	#   - 2 = bool; true -> use local DB instead of (default) replica
	#   - 3 = database name. Default 'vaionmgmt'.
	#   - 4 = bool; true -> only print the highest disk serial
	
	container="${1:-3}"
	port=$(getDBPort $container t)
	if [[ ! -z "${2:-}" ]]; then
		port=$((port - 1))
	fi
	db=${3:-vaionmgmt}

	columns="serial, name"

	highestOnly=${4:-}
	if [[ ! -z $highestOnly ]]; then
		highestOnly="LIMIT 1"
		tuplesOnly="-t"
		columns="serial"
	else
		echocolour "Getting all disks from container postgres_$container on port $port"
	fi
	
	while read diskSerial; do
		if [[ -z $highestOnly ]]; then
			echo $diskSerial
		elif [[ ! "$diskSerial" =~ ^$ ]]; then
					echo $diskSerial
		fi
	done < <(docker exec postgres_$container psql -U postgres -d $db -p $port $tuplesOnly -c "SELECT $columns FROM disks WHERE serial ~ '^[0-9]+$' ORDER BY serial DESC $highestOnly;")
}

# Check the disks with the highest serial number from both nodes 3 and 4. Print
# whether they match. The output tells you the highest number so you can compare
# it with what's expected.
#
# WARNING: If both nodes have 0 disks, they'll match.
function checkDisks {
	first=${1:-3}
	second=${2:-4}

	threeOut=$(getDisks $first '' '' t)
	fourOut=$(getDisks $second '' '' t)

	if [[ "$threeOut" = "$fourOut" ]]; then
		echo "Matching last disk '$threeOut' on both nodes"
		return 0
	else
		echocolour "Bad!!! Node 3 has '$threeOut'; node 4 has '$fourOut'"
		return 1
	fi
}

function hawatch {
	local node="${1:-2}"
	local component="${2:-mgmt}"
	local grep=
	local nogrep=

	if [[ "$component" == "mgmt" ]]; then
		grep="-E \(haservice\|db_resiliency_service\|mgmt_mode_normal.go\|recovery\)"
		nogrep="'Register connection'"
	elif [[ "$component" == "db" ]]; then
		component="postgres"
		nogrep="cleanup"
	fi

	cmd="cluster_log $node $component"
	if [[ ! -z ${nogrep+x} ]]; then
		cmd+=" | grep -iv $nogrep"
	fi
	if [[ ! -z ${grep:-} ]]; then
		cmd+=" | grep $grep"
	fi

	eval "$cmd"
}

# Pause component on node
#
#  - $1 = node (default 2)
#  - $2 = component (default ha)
function pause {
	node=${1:-2}
	component=${2:-ha}

	kill -STOP $(cat ~/cluster/$node/$component.pid)
}

# Restart component on node
#
#  - $1 = node (default 2)
#  - $2 = component (default ha)
function start {
	node=${1:-2}
	component=${2:-ha}

	kill -CONT $(cat ~/cluster/$node/$component.pid)
}

# Find file in the db component of a node
#
# Args:
#   - 1 = node
#   - 2 = file
#   - 3 = OPTIONAL directory from /
function __findFile {
	node=$1
	file=$2
	dir=${3:-/var/lib/postgresql/data/}

	test ! -z $(docker exec -it postgres_$node bash -c "ls -1 $dir" | grep $file)
}

# Check which nodes are running HA replication by looking at their file
# structures.
function haRunning {
	for node in {2..4}; do
		if $(__findFile $node ha_enabled); then
			if $(__findFile $node remote); then
				if $(__findFile $node standby.signal /var/lib/postgresql/data/remote/pg15/); then
					echo "Node $node is running replication as a STANDBY"
				else
					echo "Node $node is running replication WITHOUT QUORUM"
				fi
			else
				echo "Node $node is running replication as a MASTER"
			fi
		else
			echo "Node $node is NOT running replication"
		fi
	done				
}