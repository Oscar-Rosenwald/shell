#!/bin/bash

RED='\033[0;31m'
CYAN='\033[0;36m'
NC='\033[0m'
set -euo pipefail

if [[ $1 = -h ]]; then
	cat <<EOF

	e "${RED}logs <file> [ c | in <regex> ] [--no-tail] [--debug]${NC}"
    Give list of strings to exclude/include from the file.

            c -> toggle inclusion of colour. Default is to give coloured output.
                 Using c once will disable it on strings going forward. Using c again will re-enable it and so on.
            h -> Show first 100 lines rather than last 100 lines.
           in -> include following file. Default is exclude.
           id -> Give the 'name' of something whose ID you want to filter out (or in if the 'in' option precedes the 'id'), e.g. CC_Cloud.
           -l -> Show all filtered output in a less way.
           -L -> Show all filtered output in a less way, but scroll to the bottom.
    --no-tail -> Do not limit the output to any line number.
     --no-map -> Do not map IDs onto names.
      --debug -> Pass --debug to map-IDs.sh.
EOF
    exit 0
fi

query=""
in=

declare -a idInArray
declare -a idOutArray
declare -a inArray

mappingDir=$MAPS
colour=true
noTail=false
less=false
noMap=false
firstLast=tail
file=$1
debug=

nextIsInEntry=false # If true, the next argument follows the "in" option.
shift 1 # Exclusions from now on

while [[ $# -gt 0 ]]; do
	line="$1"
	if [[ ! -z $debug ]]; then
		echo "Adding option '$line' (which is an 'in' option: $nextIsInEntry)"
	fi

	case $line in
		"")
			break
			;;
		c)
			if [[ "$colour" = true ]]; then
				colour=false
			else
				colour=true
			fi
			;;
		h)
			firstLast=head
			;;
		--no-map)
			noMap=true
			;;
		--no-tail)
			noTail=true
			;;
		--debug)
			debug=--debug
			;;
		-l)
			less=true
			;;
		-L)
			less=fromEnd
			;;
		in)
			[[ ! -z $debug ]] && echo "Next is an 'in' argument"
			nextIsInEntry=true
			;;
		id)
			if [[ $nextIsInEntry = true ]]; then
				[[ ! -z $debug ]] && echo "Adding ID to the in array"
				idInArray+=("$2")
				nextIsInEntry=false
			else
				[[ ! -z $debug ]] && echo "Adding ID to the out array"
				idOutArray+=("$2")
			fi
			shift 1
			;;
		*)
			if [[ $nextIsInEntry = false ]]; then
				query+=" | grep -v \"$line\""
			else
				in+=" | grep -i \"$line\""
				inArray+=("$line")
				nextIsInEntry=false
			fi
	esac
	shift 1
done

logdir="$(dirname "$(realpath $file)")"
while [[ ! -f "$logdir/cluster.txt" && "$logdir" != / ]]; do
	logdir="$(dirname "$logdir")"
done

clusterTxt="$logdir"/cluster.txt
if [[ ! -f $clusterTxt ]]; then
	exit 1
fi

downloadInfoFile="$logdir"/download_info

if [[ ! -f "$downloadInfoFile" ]]; then
	tmpFile="$(dirname '$(realpath $file)')"/.vmsname
	if [[ -f $tmpFile ]]; then
		vmsName=$(cat $tmpFile)
	fi

	if [[ -z ${vmsName:-x} ]] || [[ ! -f /tmp/${vmsName:-blablabla} ]]; then
		echo "What is this VMS called? (You forgot to include a download_info file). This WILL create a permanent file."
		read -p "VMS name: " vmsName
		downloadInfoFile=/tmp/$vmsName
		echo "VMS name:" > $downloadInfoFile
		echo $vmsName >> $downloadInfoFile
		echo $vmsName > $tmpFile
	else
		downloadInfoFile=/tmp/$vmsName
	fi
fi

vmsName=$(sed -n '2p' "$downloadInfoFile")
vmsName=${vmsName/\/*/}
mappingFile=$mappingDir/$vmsName

if [[ ! -f $mappingFile ]]; then
	construct-name-mappings.sh -vms $vmsName --source "$clusterTxt"
fi

for id in "${idOutArray[@]}"; do
	idName=$(map-IDs.sh $vmsName --reverse $id)
	if [[ -z $idName ]]; then
		echocolour "No ID associated with name $id"
		exit 0
	fi
	query+=" | grep -v \"$idName\""
done

for id in "${idInArray[@]}"; do
	idName=$(map-IDs.sh $vmsName --reverse $id)
	if [[ -z $idName ]]; then
		echocolour "No ID associated with name $id"
		exit 0
	fi
	query+=" | grep -i \"$idName\""
	inArray+=("$idName")
done

# This is done so we can grep on things we grepped on before. If we grepped like this:
# 
#   grep --color=always "ahoj zdar" | grep "zdar cau"
#   
# Then there would be no results, because the first grep introduces colour to the end of
# the word 'zdar', and the second grep isn't counting on it. Therefore we need to grep
# first without colour, and then hope for the best when colour is introduced.
echo "Re-grepping ${inArray[@]}"
for g in "${inArray[@]}"; do
	in+=" | grep -i '$g'"
	if [[ $colour = true ]]; then
		in+=" --color=always"
	fi
done

command="cat $file $query $in"

if [[ $noTail = false && $less = false ]]; then
	command+=" | $firstLast -n 100"
fi

if [[ $noMap = false ]]; then
	command+=" | map-IDs.sh $vmsName $debug"
fi

if [[ $less = true ]]; then
	command+=" | less -R"
elif [[ $less = fromEnd ]]; then
	command+=" | less -R +G"
fi

newCmd="${command//$CYAN//}"
echocolour "${newCmd//$NC//}"
eval "$command"